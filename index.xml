<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Onecampus T.D.</title>
    <link>http://onecampus.github.io/</link>
    <description>Recent content on Onecampus T.D.</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <lastBuildDate>Fri, 27 Nov 2015 16:00:16 +0800</lastBuildDate>
    <atom:link href="http://onecampus.github.io/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>iOS 运行时的黑魔法 by sleeping</title>
      <link>http://onecampus.github.io/iOS%20%E8%BF%90%E8%A1%8C%E6%97%B6%E7%9A%84%E9%BB%91%E9%AD%94%E6%B3%95%20by%20sleeping/</link>
      <pubDate>Fri, 27 Nov 2015 16:00:16 +0800</pubDate>
      
      <guid>http://onecampus.github.io/iOS%20%E8%BF%90%E8%A1%8C%E6%97%B6%E7%9A%84%E9%BB%91%E9%AD%94%E6%B3%95%20by%20sleeping/</guid>
      <description>

&lt;blockquote&gt;
&lt;p&gt;”Method swizzling指的是改变一个已存在的选择器对应的实现的过程，它依赖于Objectvie-C中方法的调用能够在运行时进改变——通过改变类的调度表（dispatch table）中选择器到最终函数间的映射关系。“&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;举个例子，假设我们想跟踪在一个iOS应用中每个视图控制器展现给用户的次数：&lt;/p&gt;

&lt;p&gt;我们可以给每个视图控制器对应的viewWillAppear:实现方法中增加相应的跟踪代码，但是这样做会产生大量重复的代码。子类化可能是另一个选择，但要求你将UIViewController、 UITableViewController、 UINavigationController 以及所有其他视图控制器类都子类化，这也会导致代码重复。&lt;/p&gt;

&lt;p&gt;幸好，还有另一个方法，在分类中进行method swizzling，下面来看怎么做：&lt;/p&gt;

&lt;p&gt;在计算机学科中，指针变换（pointer swizzling）是指将基于名字或位置的引用转变为直接的指针引用。 然而在Objective-C中，这个词的起源并不完全知道，但关于这一借鉴其实也很好理解，method swizzling可以通过选择器来改变它引用的函数指针。&lt;/p&gt;

&lt;p&gt;现在，当UIViewController或它子类的任何实例触发viewWillAppear:方法都会打印一条log日志。&lt;/p&gt;

&lt;p&gt;向视图控制器的生命周期中注入操作、事件的响应、视图的绘制，或Foundation中的网络堆栈都是能够利用method swizzling产生明显效果的场景。还有一些其他的场景使用swizzling会是一个合适的选择，这随着Objective-C开发者经验不断丰富会变得越来越明显。&lt;/p&gt;

&lt;p&gt;先不说为什么和在哪些地方使用swizzling，来看一下应该怎样实现：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
    1   #import &amp;lt;objc/runtime.h&amp;gt; 
    2    
    3   @implementation UIViewController (Tracking) 
    4    
    5   + (void)load { 
    6       static dispatch_once_t onceToken; 
    7       dispatch_once(&amp;amp;onceToken, ^{ 
    8           Class class = [self class]; 
    9    
    10          // When swizzling a class method, use the following: 
    11          // Class class = object_getClass((id)self); 
    12   
    13          SEL originalSelector = @selector(viewWillAppear:); 
    14          SEL swizzledSelector = @selector(xxx_viewWillAppear:); 
    15   
    16          Method originalMethod = class_getInstanceMethod(class, originalSelector); 
    17          Method swizzledMethod = class_getInstanceMethod(class, swizzledSelector); 
    18   
    19          BOOL didAddMethod = 
    20              class_addMethod(class, 
    21                  originalSelector, 
    22                  method_getImplementation(swizzledMethod), 
    23                  method_getTypeEncoding(swizzledMethod)); 
    24   
    25          if (didAddMethod) { 
    26              class_replaceMethod(class, 
    27                  swizzledSelector, 
    28                  method_getImplementation(originalMethod), 
    29                  method_getTypeEncoding(originalMethod)); 
    30          } else { 
    31              method_exchangeImplementations(originalMethod, swizzledMethod); 
    32          } 
    33      }); 
    34  } 
    35   
    36  #pragma mark - Method Swizzling 
    37   
    38  - (void)xxx_viewWillAppear:(BOOL)animated { 
    39      [self xxx_viewWillAppear:animated]; 
    40      NSLog(@&amp;quot;viewWillAppear: %@&amp;quot;, self); 
    41  } 
    42   
    43  @end 

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;+load vs. +initialize&lt;/p&gt;

&lt;p&gt;Swizzling应该在+load方法中实现。&lt;/p&gt;

&lt;p&gt;Swizzling应该在+load方法中实现。
每个类的这两个方法会被Objective-C运行时系统自动调用，+load是在一个类最开始加载时调用，+initialize是在应用中第一次调用该类或它的实例的方式之前调用。这两个方法都是可选的，只有实现了才会被执行。&lt;/p&gt;

&lt;p&gt;因为method swizzling会影响全局，所以减少冒险情况就很重要。+load能够保证在类初始化的时候就会被加载，这为改变系统行为提供了一些统一性。但+initialize并不能保证在什么时候被调用——事实上也有可能永远也不会被调用，例如应用程序从未直接的给该类发送消息。&lt;/p&gt;

&lt;p&gt;dispatch_once
Swizzling应该在dispatch_once中实现。
 
还是因为swizzling会改变全局，我们需要在运行时采取所有可用的防范措施。保障原子性就是一个措施，它确保代码即使在多线程环境下也只会被执行一次。GCD中的diapatch_once就提供这些保障，它应该被当做swizzling的标准实践。&lt;/p&gt;

&lt;h2 id=&#34;选择器-方法及实现:28fe0b77f5108a1798883e2de2677997&#34;&gt;选择器、方法及实现&lt;/h2&gt;

&lt;p&gt;在Objective-C中，尽管这些词经常被放在一起来描述消息传递的过程，但选择器、方法及实现分别代表运行时的不同方面。
下面是苹果Objective-C Runtime Reference文档中对它们的描述:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;选择器（typedef struct objc_selector *SEL）：选择器用于表示一个方法在运行时的名字，一个方法的选择器是一个注册到（或映射到）Objective-C运行时中的C字符串，它是由编译器生成并在类加载的时候被运行时系统自动映射。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;方法（typedef struct objc_method *Method）：一个代表类定义中一个方法的不明类型。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;实现（typedef id (*IMP)(id, SEL, &amp;hellip;)）：这种数据类型是实现某个方法的函数开始位置的指针，函数使用的是基于当前CPU架构的标准C调用规约。第一个参数是指向self的指针（也就是该类的某个实例的内存空间，或者对于类方法来说，是指向元类（metaclass）的指针）。第二个参数是方法的选择器，后面跟的都是参数。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;理解这些概念之间关系最好的方式是：一个类（Class）维护一张调度表（dispatch table）用于解析运行时发送的消息；调度表中的每个实体（entry）都是一个方法（Method），其中key值是一个唯一的名字——选择器（SEL），它对应到一个实现（IMP）——实际上就是指向标准C函数的指针。&lt;/p&gt;

&lt;p&gt;Method Swizzling就是改变类的调度表让消息解析时从一个选择器对应到另外一个的实现，同时将原始的方法实现混淆到一个新的选择器。&lt;/p&gt;

&lt;p&gt; &lt;/p&gt;

&lt;h4 id=&#34;调用-cmd:28fe0b77f5108a1798883e2de2677997&#34;&gt;调用_cmd&lt;/h4&gt;

&lt;p&gt;下面这段代码看起来像是会导致一个死循环：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
    1   - (void)xxx_viewWillAppear:(BOOL)animated { 
    2       [self xxx_viewWillAppear:animated]; 
    3       NSLog(@&amp;quot;viewWillAppear: %@&amp;quot;, NSStringFromClass([self class])); 
    4   } 

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;但其实并没有，在Swizzling的过程中，xxx_viewWillAppear:会被重新分配给UIViewController的-viewWillAppear:的原始实现。一个优秀程序员应有的直觉会告诉你在一个方法的实现中通过self调用当前方法自身会产生错误，但是在当前这种情况下，如果我们记住到底是怎么回事更有意义。反而，如果我们在这个方法中调用viewWillAppear:才会真的导致死循环，因为这个方法的实现会在运行时被swizzle到viewWillAppear:的选择器。
 
记住给swizzled方法加上前缀，这和你需要给可能产生冲突的分类方法加前缀是一个道理。&lt;/p&gt;

&lt;h4 id=&#34;注意事项:28fe0b77f5108a1798883e2de2677997&#34;&gt;注意事项&lt;/h4&gt;

&lt;p&gt;Swizzling被普遍认为是一种巫术，容易导致不可预料的行为和结果。尽管不是最安全的，但是如果你采取下面这些措施，method swizzling还是很安全的。&lt;/p&gt;

&lt;p&gt;1.始终调用方法的原始实现（除非你有足够的理由不这么做）： API为输入和输出提供规约，但它里面具体的实现其实是个黑匣子，在Method Swizzling过程中不调用它原始的实现可能会破坏一些私有状态，甚至是程序的其他部分。&lt;/p&gt;

&lt;p&gt;2.避免冲突：给分类方法加前缀，一定要确保不要让你代码库中其他代码（或是依赖库）在做与你相同的事。&lt;/p&gt;

&lt;p&gt;3.理解：只是简单的复制粘贴swizzling代码而不去理解它是怎么运行的，这不仅非常危险，而且还浪费了学习Objective-C运行时的机会。阅读 Objective-C Runtime Reference 和 &lt;objc/rumtime.h&gt; 去理解代码是怎样和为什么这样执行的，努力的用你的理解来消灭你的疑惑。&lt;/p&gt;

&lt;p&gt;谨慎行事：不管你多么自信你能够swizzling Foundation、UIKit 或者其他内置框架，请记住所有这些都可能在下一个版本中就不好使。提前做好准备，防范于未然才不至于到时候焦头烂额。&lt;/p&gt;

&lt;p&gt;不敢放心大胆的直接使用Objective-C运行时？Jonathan ‘Wolf’ Rentzsch提供了经过实战检验的、支持CocoaPads的库JRSwizzle，它会为你考虑好了一切。
Have Fun！&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>使用Capistrano部署Rails应用</title>
      <link>http://onecampus.github.io/use-capistrano-to-deploy-rails-application/</link>
      <pubDate>Sun, 08 Nov 2015 18:34:27 +0800</pubDate>
      
      <guid>http://onecampus.github.io/use-capistrano-to-deploy-rails-application/</guid>
      <description>

&lt;p&gt;Capistrano是一个远程服务器自动化工具，使用Ruby编写。&lt;/p&gt;

&lt;p&gt;它是一个通用类型的工具，并非专为Rails设计，但对Rails支持很好。&lt;/p&gt;

&lt;h2 id=&#34;优点:a5c196b499269ed4a24884aad9a7b394&#34;&gt;优点&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;无需对服务器进行任何配置&lt;/li&gt;
&lt;li&gt;一键部署、回滚&lt;/li&gt;
&lt;li&gt;易于扩展，可方便地添加自定义任务&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;基本原理:a5c196b499269ed4a24884aad9a7b394&#34;&gt;基本原理&lt;/h2&gt;

&lt;p&gt;预先定义一系列任务（本质上都是shell脚本），然后通过ssh在远程服务器上执行任务。&lt;/p&gt;

&lt;p&gt;使用钩子定义任务的执行时间、顺序。&lt;/p&gt;

&lt;p&gt;可创建多套部署方案，capistrano中称为stage，每个stage有一个单独的配置文件。&lt;/p&gt;

&lt;h2 id=&#34;基本流程:a5c196b499269ed4a24884aad9a7b394&#34;&gt;基本流程&lt;/h2&gt;

&lt;p&gt;假定服务器上使用Nginx + Passenger + Rvm运行Rails应用，具体安装配置参见各软件文档。&lt;/p&gt;

&lt;p&gt;部署Rails应用的基本流程是：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;将代码推送到远程仓库&lt;/li&gt;
&lt;li&gt;本地执行capistrano部署命令&lt;/li&gt;
&lt;li&gt;capistrano通过ssh连接远程服务器，从远程代码仓库拉取代码，然后执行安装依赖、编译资源文件、迁移数据库等任务&lt;/li&gt;
&lt;li&gt;重启passenger使新代码生效&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;基本要求:a5c196b499269ed4a24884aad9a7b394&#34;&gt;基本要求&lt;/h2&gt;

&lt;h3 id=&#34;服务器:a5c196b499269ed4a24884aad9a7b394&#34;&gt;服务器&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;有一个部署用的用户，该用户应对部署目录有读写权限，且有执行rvm, passenger-config等命令的权限&lt;/li&gt;
&lt;li&gt;可连接远程代码仓库（不要求部署用户有拉取权限）&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;本地:a5c196b499269ed4a24884aad9a7b394&#34;&gt;本地&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;能通过ssh密钥以部署用户身份登录远程服务器&lt;/li&gt;
&lt;li&gt;对远程代码仓库有拉取权限&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;安装:a5c196b499269ed4a24884aad9a7b394&#34;&gt;安装&lt;/h2&gt;

&lt;p&gt;只需在本地安装capistrano&lt;/p&gt;

&lt;p&gt;在项目的Gemfile中加入以下内容：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;group :development do
  # deploy
  gem &#39;capistrano-rails&#39;, &#39;~&amp;gt; 1.1.5&#39;
  gem &#39;capistrano-rvm&#39;
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;执行&lt;code&gt;bundle install&lt;/code&gt;安装新依赖&lt;/p&gt;

&lt;h2 id=&#34;本地初始化:a5c196b499269ed4a24884aad9a7b394&#34;&gt;本地初始化&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;bundle exec cap install STAGES=development,production
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;初始化后生成以下文件结构&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;├── Capfile                # 控制插件、任务的加载
├── config
│   ├── deploy             # 不同stage的配置文件
│   │   ├── development.rb
│   │   └── production.rb
│   └── deploy.rb          # 全局配置，各stage共用
└── lib
    └── capistrano
            └── tasks      # 自定义任务的存放位置
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;若初始化时不指定STAGES，默认创建staging, production两个stage。&lt;/p&gt;

&lt;h2 id=&#34;配置:a5c196b499269ed4a24884aad9a7b394&#34;&gt;配置&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;加载rails, rvm插件&lt;/p&gt;

&lt;p&gt;在&lt;code&gt;Capfile&lt;/code&gt;中加入&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;require &#39;capistrano/rails&#39;
require &#39;capistrano/rvm&#39;
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;修改全局配置config/deploy.rb&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;# 应用名称
set :application, &#39;liveneeq&#39;

# 远程仓库地址
set :repo_url, &#39;git@git.thecampus.cc:yang/liveneeq2.git&#39;

# 服务器端部署目录。可使用fetch(:xxx)获取已设置的变量
set :deploy_to, &amp;quot;/data/app/www/#{fetch(:application)}&amp;quot;

# 在不同版本间共享的文件
set :linked_files, fetch(:linked_files, []).push(&#39;config/database.yml&#39;, &#39;config/secrets.yml&#39;)

# 在不同版本间共享的目录
set :linked_dirs, fetch(:linked_dirs, []).push(&#39;log&#39;, &#39;tmp/pids&#39;, &#39;tmp/cache&#39;, &#39;tmp/sockets&#39;, 
    &#39;vendor/bundle&#39;, &#39;public/system&#39;, &#39;public/uploads&#39;)

# ruby版本
set :rvm_ruby_version, &#39;2.2.2&#39;

# 默认Rails.env会等于stage的名称而非始终production，导致代码中判断模式错误。此处强制所有stage都为production模式
set :stage, :production
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;修改各个stage的配置&lt;/p&gt;

&lt;p&gt;我们使用development, production两个stage，development部署dev分支到开发/测试服务器，production部署master分支到生产服务器&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;# config/deploy/development.rb:

# 远程服务器的地址、用户、角色
# 可配置多台服务器
server &#39;119.29.107.35&#39;, user: &#39;ubuntu&#39;, roles: %w(app db web)

# 要部署的分支
set :branch, &#39;dev&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;# config/deploy/production.rb

# 远程服务器的地址、用户、角色
# 可配置多台服务器
server &#39;119.29.107.35&#39;, user: &#39;ubuntu&#39;, roles: %w(app db web)

# 要部署的分支
set :branch, &#39;master&#39;
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;服务器端初始化:a5c196b499269ed4a24884aad9a7b394&#34;&gt;服务器端初始化&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;创建部署目录&lt;/li&gt;
&lt;li&gt;在部署目录下创建shared子目录，里面添加config/deploy.rb中配置的linked_files&lt;/li&gt;
&lt;li&gt;创建数据库&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;capistrano命令:a5c196b499269ed4a24884aad9a7b394&#34;&gt;Capistrano命令&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# 查看可用任务
bundle exec cap -T

# 部署
bundle exec cap STAGE_NAME deploy

# 回滚
bundle exec cap STAGE_NAME deploy:rollback
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;执行任何任务都需要指定stage名称&lt;/li&gt;
&lt;li&gt;使用&lt;code&gt;bundle exec&lt;/code&gt;执行cap命令以避免不可预知的风险&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;自定义任务:a5c196b499269ed4a24884aad9a7b394&#34;&gt;自定义任务&lt;/h2&gt;

&lt;h3 id=&#34;集成bower:a5c196b499269ed4a24884aad9a7b394&#34;&gt;集成bower&lt;/h3&gt;

&lt;p&gt;若项目中使用bower管理前端依赖，需自行添加任务安装bower依赖&lt;/p&gt;

&lt;p&gt;创建&lt;code&gt;lib/capistrano/tasks/bower.rake&lt;/code&gt;文件，内容如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;namespace :bower do
  desc &#39;Install bower dependencies&#39;
  task :install do
    on roles(:web) do |host|
      within release_path do
        # 安装依赖
        execute :bower, :install
        # 清理无用包
        execute :bower, :prune
        info &amp;quot;Bower dependencies installed successfully on #{host}&amp;quot;
      end
    end
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后在&lt;code&gt;config/deploy.rb&lt;/code&gt;末尾加入&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;before :&#39;deploy:compile_assets&#39;, :&#39;bower:install&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;部署后重启passenger:a5c196b499269ed4a24884aad9a7b394&#34;&gt;部署后重启passenger&lt;/h3&gt;

&lt;p&gt;部署新版本后需要重启passenger才能使新代码生效，可通过&lt;a href=&#34;https://github.com/capistrano/passenger&#34;&gt;capistrano-passenger&lt;/a&gt;插件实现部署完成后自动重启，也可自行添加一个重启任务：&lt;/p&gt;

&lt;p&gt;创建&lt;code&gt;lib/capistrano/tasks/restart.rb&lt;/code&gt;，内容如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;namespace :passenger do
  desc &#39;Restart passenger app&#39;
  task :restart do
    on roles(:app), in: :sequence, wait: 5, limit: 2 do |host|
      # 若使用的是passenger企业版，可添加参数--rolling-restart以实现无缝重启
      execute :&#39;passenger-config&#39;, &#39;restart-app&#39;, fetch(:deploy_to), &#39;--ignore-app-not-running&#39;
      info &amp;quot;Restart passenger successfully on #{host}&amp;quot;
    end
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后在&lt;code&gt;conig/deploy.rb&lt;/code&gt;末尾加入&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;after :&#39;deploy:publishing&#39;, :&#39;passenger:restart&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;不足之处:a5c196b499269ed4a24884aad9a7b394&#34;&gt;不足之处&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;非完全自动化，只能说是半自动，因为需要本地执行部署命令&lt;/li&gt;
&lt;li&gt;完全依赖本地环境，配置在本地，执行命令在本地，而且要求本地用户能ssh登录服务器&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;曾经使用git hook + shell脚本实现过一种部署方案，指定的分支有更新（主动推送到远程仓库或在GitLab上接受合并请求）时就自动部署。&lt;/p&gt;

&lt;p&gt;完全自动化、完全不依赖本地环境，但服务器端的配置略麻烦。&lt;/p&gt;

&lt;p&gt;两种方案各有优劣，或许结合一下会更好？&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>css3属性选择器、伪类一览 by dongyu</title>
      <link>http://onecampus.github.io/css3%E5%B1%9E%E6%80%A7%E9%80%89%E6%8B%A9%E5%99%A8%E3%80%81%E4%BC%AA%E7%B1%BB%E4%B8%80%E8%A7%88/</link>
      <pubDate>Fri, 30 Oct 2015 11:57:29 +0800</pubDate>
      
      <guid>http://onecampus.github.io/css3%E5%B1%9E%E6%80%A7%E9%80%89%E6%8B%A9%E5%99%A8%E3%80%81%E4%BC%AA%E7%B1%BB%E4%B8%80%E8%A7%88/</guid>
      <description>

&lt;h2 id=&#34;css3属性选择器-伪类一览:eb47591866dfe110313e76e2d9706760&#34;&gt;css3属性选择器、伪类一览&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;注： 部分例子代码使用scss（啥？看不懂scss？拜拜）。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;属性选择器&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;1.*开始子串属性选择器*：&lt;code&gt;E[attr^=&#39;value&#39;]{}&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;a[title^=&#39;website&#39;] {}
&amp;lt;p&amp;gt;one&amp;lt;a href=&amp;quot;www.baidu.com&amp;quot; title=&amp;quot;website&amp;quot;&amp;gt;&amp;lt;/a&amp;gt;&amp;lt;/p&amp;gt;
&amp;lt;p&amp;gt;two&amp;lt;a href=&amp;quot;www.baidu.com&amp;quot; title=&amp;quot;anther website&amp;quot;&amp;gt;&amp;lt;/a&amp;gt;&amp;lt;/p&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;解释：该规则会匹配第一个段落中的a元素，因为它的title属性字符串以单词website开头。而第二个段落a的title虽包含了website但由于不是开头单词，所以不会匹配。&lt;/p&gt;

&lt;p&gt;2.*结束子串属性选择器*：&lt;code&gt;E[attr$=&#39;value&#39;]{}&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;a {
  &amp;amp;[href$=&#39;.doc&#39;] {
    background: #fff;
  }
  &amp;amp;[href$=&#39;.pdf&#39;] {
    background: red;
  }
}
&amp;lt;a href=&#39;http://onecampus.github.io/example.doc&#39;&amp;gt;i am a doc&amp;lt;/a&amp;gt;
&amp;lt;a href=&#39;http://onecampus.github.io/example.pdf&#39;&amp;gt;i am a pdf&amp;lt;/a&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;解释：该规则会匹配以相应单词结尾的元素段落,所以.doc规则会匹配第一个元素a,而.pdf会匹配第二个元素a。&lt;/p&gt;

&lt;p&gt;3.*任意子串属性值选择器*：&lt;code&gt;E[attr*=&#39;value&#39;]{}&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;a[title*=&#39;website&#39;] {}
&amp;lt;p&amp;gt;one&amp;lt;a href=&amp;quot;www.baidu.com&amp;quot; title=&amp;quot;website&amp;quot;&amp;gt;&amp;lt;/a&amp;gt;&amp;lt;/p&amp;gt;
&amp;lt;p&amp;gt;two&amp;lt;a href=&amp;quot;www.baidu.com&amp;quot; title=&amp;quot;anther website&amp;quot;&amp;gt;&amp;lt;/a&amp;gt;&amp;lt;/p&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;解释：该规则会匹配两个段落元素里面的a元素，因为他们的title都包含有website&lt;/p&gt;

&lt;p&gt;4.*多属性选择器*：&lt;code&gt;E[attr^=&#39;value&#39;][attr$=&#39;value&#39;] {}&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;a[href*=&#39;http://&#39;][href$=&#39;.com&#39;] {}
&amp;lt;p&amp;gt;one&amp;lt;a href=&amp;quot;http://www.baidu.com&amp;quot; title=&amp;quot;website&amp;quot;&amp;gt;&amp;lt;/a&amp;gt;&amp;lt;/p&amp;gt;
&amp;lt;p&amp;gt;two&amp;lt;a href=&amp;quot;www.baidu.com&amp;quot; title=&amp;quot;anther website&amp;quot;&amp;gt;&amp;lt;/a&amp;gt;&amp;lt;/p&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;解释：该规则的意思是匹配属性值href以http://开头且以.com结尾的元素，故第一个元素a会被匹配&lt;/p&gt;

&lt;p&gt;5.*普通兄弟连接符*： &lt;code&gt;E ~ F {}&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;h2 ~ p {
  font-weight: bolder;
}
&amp;lt;p&amp;gt;i am p1&amp;lt;/p&amp;gt;
&amp;lt;h2&amp;gt;today is good&amp;lt;/h2&amp;gt;
&amp;lt;p&amp;gt;i am p2&amp;lt;/p&amp;gt;
&amp;lt;p&amp;gt;i am p3&amp;lt;/p&amp;gt;
&amp;lt;blockquote&amp;gt;
  &amp;lt;p&amp;gt;i am p4&amp;lt;/p&amp;gt;
&amp;lt;/blockquote&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;解释：该规则匹配同一层级的位于h2元素之后的任意p元素，所以p2,p3字体会变粗。而p1不在h2之后，p4和h2不在同一层级，所以不会有变化&lt;/p&gt;

&lt;p&gt;&lt;em&gt;特别提示： 属性选择器对属性的大小写不敏感，而且所有主流的浏览器都兼容，可以放心大胆的使用。&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;伪类&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;1.nth-of-type与nth-child&lt;/em&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;div&amp;gt;* {
  &amp;amp;:nth-of-type(2) {
    color: red;
  }
  &amp;amp;:nth-child(2) {
    color: white;
  }
}
&amp;lt;div&amp;gt;
  &amp;lt;h2&amp;gt;who win?&amp;lt;/h2&amp;gt;
  &amp;lt;p&amp;gt;exo&amp;lt;/p&amp;gt;
  &amp;lt;p&amp;gt;or&amp;lt;/p&amp;gt;
  &amp;lt;p&amp;gt;tfb&amp;lt;/p&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;解释： 两者基本用法一致，唯一不同的地方在于元素个数不受或受元素类型影响。例子中第二个p元素文字变红，因为nth-of-type忽略了h2进行计算，而第一个元素p文字变白，因为nth-child从h2开始计算。&lt;/p&gt;

&lt;p&gt;一些补充用法：&lt;br /&gt;
匹配基数项：&lt;code&gt;E:nth-child(odd) {}&lt;/code&gt;&lt;br /&gt;
匹配偶数项：&lt;code&gt;E:nth-child(even) {}&lt;/code&gt;&lt;br /&gt;
自定义,n从1开始: &lt;code&gt;E:nth-child(2n) {}&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;2.nth-last-of-type与nth-last-child&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;解释: 这两个是从元素的末尾开始计算，其余用法与用例1中一致。这里列举一个实用的例子&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//问题：假设想让最后两行的元素p文字变成红色应该怎么写？
&amp;lt;div&amp;gt;
  &amp;lt;p&amp;gt;hahaha&amp;lt;/p&amp;gt;
  &amp;lt;p&amp;gt;exo&amp;lt;/p&amp;gt;
  &amp;lt;p&amp;gt;or&amp;lt;/p&amp;gt;
  &amp;lt;p&amp;gt;tfb&amp;lt;/p&amp;gt;
&amp;lt;/div&amp;gt;
//解答(加一个-号使得nth-last-of-type文档树计算向前走（什么意思？n代入1，2，3，4算一算就知道了）)
p:nth-last-of-type(-n+2) {
    color: red;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;3.first-child、first-of-type、last-child、last-of-type&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;first-of-type： 匹配父元素的基于类型的第一个子元素&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;div&amp;gt;*:first-of-type {
  color: red;
}
&amp;lt;div&amp;gt;
  &amp;lt;h2&amp;gt;who win?&amp;lt;/h2&amp;gt;
  &amp;lt;p&amp;gt;exo&amp;lt;/p&amp;gt;
  &amp;lt;p&amp;gt;or&amp;lt;/p&amp;gt;
  &amp;lt;p&amp;gt;tfb&amp;lt;/p&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;解释： 第一个p元素文字和h2元素都会变红&lt;/p&gt;

&lt;p&gt;first-child： 匹配父元素的基于结构上的的第一个子元素&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;div&amp;gt;*:first-of-type {
  color: red;
}
&amp;lt;div&amp;gt;
  &amp;lt;h2&amp;gt;who win?&amp;lt;/h2&amp;gt;
  &amp;lt;p&amp;gt;exo&amp;lt;/p&amp;gt;
  &amp;lt;p&amp;gt;or&amp;lt;/p&amp;gt;
  &amp;lt;p&amp;gt;tfb&amp;lt;/p&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;解释： h2元素会变红，p元素无变化&lt;/p&gt;

&lt;p&gt;last-child、last-of-type指的是父元素的最后一个子元素，其他与上述两者一致。&lt;/p&gt;

&lt;p&gt;&lt;em&gt;4.only-child、only-of-child&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;only-child: 匹配父元素内有且只有一个子元素项(结构上数目1)&lt;br /&gt;
only-of-child： 匹配父元素内有且只有一个不同类型的子元素项(类型上数目1)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;p {
  &amp;amp;:only-child {
    color: red;
  }
  &amp;amp;:only-of-type {
    font-size: 50px;
  }
}
&amp;lt;p&amp;gt;i am p1&amp;lt;/p&amp;gt;
&amp;lt;span&amp;gt;i am span&amp;lt;/span&amp;gt;
&amp;lt;span&amp;gt;i am span too&amp;lt;/span&amp;gt;
&amp;lt;blockquote&amp;gt;
  &amp;lt;p&amp;gt;i am p2&amp;lt;/p&amp;gt;
&amp;lt;/blockquote&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;表现： p2文字会变为红色和50px，p1会变为50px，其余无变化&lt;br /&gt;
解释：由于p1在该相同层级内类型唯一，所以only-of-type会起作用，而该层级元素个数不为1，所以p1文字大小无变化。p2在层级中无论数目或类型都唯一，所以对only-child与only-of-type都有响应。&lt;/p&gt;

&lt;p&gt;&lt;em&gt;5.target，打开内部链接伪类&lt;/em&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;div {
  display: none;
  &amp;amp;:target {
   display: block;
  }
}
&amp;lt;a href=&#39;#demo&#39;&amp;gt;clickme&amp;lt;/a&amp;gt;
&amp;lt;div id=&#39;demo&#39;&amp;gt;haha&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;解释： 点击clickme按钮之后haha会出现，该效果可以制作不需要依赖js的tag切换效果。&lt;/p&gt;

&lt;p&gt;&lt;em&gt;6.empty 空元素伪类&lt;/em&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;div:empty {
  background: red;
  width: 100px;
  height: 100px;
}
&amp;lt;div&amp;gt;&amp;lt;/div&amp;gt;
&amp;lt;div&amp;gt;123456&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;解释: 该规则只会匹配第一个div元素&lt;/p&gt;

&lt;p&gt;&lt;em&gt;7.E: not(F) { } 否定元素伪类&lt;/em&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//问题： 除了第一个p元素之外其他p元素文字要变成红色怎么玩？
&amp;lt;div&amp;gt;
  &amp;lt;p&amp;gt;i am p1&amp;lt;/p&amp;gt;
  &amp;lt;p&amp;gt;i am p2&amp;lt;/p&amp;gt;
  &amp;lt;p&amp;gt;i am p3&amp;lt;/p&amp;gt;
  &amp;lt;p&amp;gt;i am p4&amp;lt;/p&amp;gt;
  &amp;lt;p&amp;gt;i am p5&amp;lt;/p&amp;gt;
&amp;lt;/div&amp;gt;
//解答： so easy,
p:not(:first-child) {
  color: red;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;特别提示： 伪类webkit,firefox,opera和ie9+浏览器兼容（啥？旧版ie也想用？可以的，不过需要依赖js的补丁包，这里就不做介绍了）&lt;/em&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>browsersync基础教程 by dongyu</title>
      <link>http://onecampus.github.io/browsersync%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/</link>
      <pubDate>Fri, 30 Oct 2015 10:21:57 +0800</pubDate>
      
      <guid>http://onecampus.github.io/browsersync%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/</guid>
      <description>

&lt;h2 id=&#34;browser-sync基础配置:1ed05c9306fa0fc57aae4353611ca792&#34;&gt;browser-sync基础配置&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&#34;http://www.browsersync.io/&#34;&gt;browser-sync&lt;/a&gt;是个啥？&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;browser-sync是一个前端辅助性插件，用于开发时自动刷新页面。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;这玩意有什么优势？&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ol&gt;
&lt;li&gt;不需要写任何代码，直接几个命令就能控制监听自动刷新，很爽有木有？&lt;/li&gt;
&lt;li&gt;响应式开发时可能需要在多种设备或者屏幕上测试，browser-sync能一次性帮你刷新所有页面，简直是懒人必备啊（啥？什么是响应式？拜拜）。&lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
&lt;p&gt;how to install?&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ol&gt;
&lt;li&gt;需要npm环境，这个下载安装&lt;a href=&#34;https://nodejs.org/en/&#34;&gt;nodejs&lt;/a&gt;之后就有了&lt;/li&gt;
&lt;li&gt;npm install -g browser-sync&lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
&lt;p&gt;问： 我已经有个服务器eg: localhost:4200，我想用browser-sync来监听文件的变化该怎么做？&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ol&gt;
&lt;li&gt;开启你的服务器并确保ip不是3000(3000被占用的话browser-sync会开启失败)&lt;/li&gt;
&lt;li&gt;browser-sync start &amp;ndash;proxy &amp;ldquo;localhost:4200&amp;rdquo; &amp;ndash;files &amp;ldquo;js/.js,css/.css&amp;rdquo;&lt;br /&gt;
&amp;ndash;proxy: 启动一个内置的服务器&lt;br /&gt;
&amp;ndash;files: 要监听变化的对象（如果实在不知道要监听什么，可以这样写**,不过不推荐这么做..）&lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
&lt;p&gt;个人感觉browser-sync美中不足的地方&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ol&gt;
&lt;li&gt;监听对象是css文件自动注入不刷新页面的机制才会生效，但监听对象是诸如scss一类文件的时候注入就不生效了，页面还是会刷新。&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>栅格化设计 by mj</title>
      <link>http://onecampus.github.io/%E6%A0%85%E6%A0%BC%E5%8C%96%E8%AE%BE%E8%AE%A1/</link>
      <pubDate>Wed, 28 Oct 2015 15:34:00 +0800</pubDate>
      
      <guid>http://onecampus.github.io/%E6%A0%85%E6%A0%BC%E5%8C%96%E8%AE%BE%E8%AE%A1/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;栅格化设计-01.jpg&#34; alt=&#34;&#34; /&gt;
&lt;br /&gt;
&lt;img src=&#34;栅格化设计-02.jpg&#34; alt=&#34;&#34; /&gt;
&lt;br /&gt;
&lt;img src=&#34;栅格化设计-03.jpg&#34; alt=&#34;&#34; /&gt;
&lt;br /&gt;
&lt;img src=&#34;栅格化设计-04.jpg&#34; alt=&#34;&#34; /&gt;
&lt;br /&gt;
&lt;img src=&#34;栅格化设计-05.jpg&#34; alt=&#34;&#34; /&gt;
&lt;br /&gt;
&lt;img src=&#34;栅格化设计-06.jpg&#34; alt=&#34;&#34; /&gt;
&lt;br /&gt;
&lt;img src=&#34;栅格化设计-07.jpg&#34; alt=&#34;&#34; /&gt;
&lt;br /&gt;
&lt;img src=&#34;栅格化设计-08.jpg&#34; alt=&#34;&#34; /&gt;
&lt;br /&gt;
&lt;img src=&#34;栅格化设计-09.jpg&#34; alt=&#34;&#34; /&gt;
&lt;br /&gt;
&lt;img src=&#34;栅格化设计-10.jpg&#34; alt=&#34;&#34; /&gt;
&lt;br /&gt;
&lt;img src=&#34;栅格化设计-11.jpg&#34; alt=&#34;&#34; /&gt;
&lt;br /&gt;
&lt;img src=&#34;栅格化设计-12.jpg&#34; alt=&#34;&#34; /&gt;
&lt;br /&gt;
&lt;img src=&#34;栅格化设计-13.jpg&#34; alt=&#34;&#34; /&gt;
&lt;br /&gt;
&lt;img src=&#34;栅格化设计-14.jpg&#34; alt=&#34;&#34; /&gt;
&lt;br /&gt;
&lt;img src=&#34;栅格化设计-15.jpg&#34; alt=&#34;&#34; /&gt;
&lt;br /&gt;
&lt;img src=&#34;栅格化设计-16.jpg&#34; alt=&#34;&#34; /&gt;
&lt;br /&gt;
&lt;img src=&#34;栅格化设计-17.jpg&#34; alt=&#34;&#34; /&gt;
&lt;br /&gt;
&lt;img src=&#34;栅格化设计-18.jpg&#34; alt=&#34;&#34; /&gt;
&lt;br /&gt;
&lt;img src=&#34;栅格化设计-19.jpg&#34; alt=&#34;&#34; /&gt;
&lt;br /&gt;
&lt;img src=&#34;栅格化设计-20.jpg&#34; alt=&#34;&#34; /&gt;
&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>网页弹性按钮(纯css3) by zhou</title>
      <link>http://onecampus.github.io/%E7%BD%91%E9%A1%B5%E5%BC%B9%E6%80%A7%E6%8C%89%E9%92%AE/</link>
      <pubDate>Sun, 25 Oct 2015 15:55:29 +0800</pubDate>
      
      <guid>http://onecampus.github.io/%E7%BD%91%E9%A1%B5%E5%BC%B9%E6%80%A7%E6%8C%89%E9%92%AE/</guid>
      <description>

&lt;h2 id=&#34;网页中弹性按钮设计-纯css:e2661edcf3ad09a929f3c6c9ad328c35&#34;&gt;网页中弹性按钮设计(纯CSS)&lt;/h2&gt;

&lt;p&gt;效果如下：
&lt;img src=&#34;../btn.gif&#34; alt=&#34;image&#34; /&gt;
&lt;/p&gt;

&lt;h4 id=&#34;思路:e2661edcf3ad09a929f3c6c9ad328c35&#34;&gt;思路&lt;/h4&gt;

&lt;p&gt;其中包含2个动效，第一个是按钮中心的颜色扩散，第二个是按钮弹性收缩。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;第一个颜色扩散：按钮分为了两层，第一层是按钮本身，第二层是按钮的为元素:before，&lt;strong&gt;注意按钮before是这个效果的重点，通过hover动作触发按钮before层的扩散&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;第二个弹性收缩：需要使用@keyframes设计动画的效果。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;两个动画独立完成后，重叠在一起的话，需要调整动画的时间及效果。&lt;/p&gt;

&lt;h4 id=&#34;代码分析:e2661edcf3ad09a929f3c6c9ad328c35&#34;&gt;代码分析&lt;/h4&gt;

&lt;p&gt;html&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;div class=&amp;quot;bottle&amp;quot;&amp;gt;
  &amp;lt;a class=&amp;quot;hvr-rectangle-out hvr-pop&amp;quot; href=&amp;quot;javascript:void(0)&amp;quot;&amp;gt;1&amp;lt;/a&amp;gt;
&amp;lt;/div&amp;gt;
  &amp;lt;div class=&amp;quot;bottle&amp;quot;&amp;gt;
  &amp;lt;a class=&amp;quot;hvr-rectangle-out hvr-pop&amp;quot; href=&amp;quot;javascript:void(0)&amp;quot;&amp;gt;2&amp;lt;/a&amp;gt;
&amp;lt;/div&amp;gt;
  &amp;lt;div class=&amp;quot;bottle&amp;quot;&amp;gt;
  &amp;lt;a class=&amp;quot;hvr-rectangle-out hvr-pop&amp;quot; href=&amp;quot;javascript:void(0)&amp;quot;&amp;gt;3&amp;lt;/a&amp;gt;
&amp;lt;/div&amp;gt;
  &amp;lt;div class=&amp;quot;bottle&amp;quot;&amp;gt;
  &amp;lt;a class=&amp;quot;hvr-rectangle-out hvr-pop&amp;quot; href=&amp;quot;javascript:void(0)&amp;quot;&amp;gt;4&amp;lt;/a&amp;gt;
&amp;lt;/div&amp;gt;
  &amp;lt;div class=&amp;quot;bottle&amp;quot;&amp;gt;
  &amp;lt;a class=&amp;quot;hvr-rectangle-out hvr-pop&amp;quot; href=&amp;quot;javascript:void(0)&amp;quot;&amp;gt;5&amp;lt;/a&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;css&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-css&#34;&gt;/*按钮基础样式*/
.bottle {
  display: block;
  width: 50px;
  height: 50px;
  margin-bottom: 5px;
}
.bottle a {
  text-decoration: none;
  color: gray;
}
/*颜色扩散动效部分*/
.hvr-rectangle-out {
  display: inline-block;
  vertical-align: middle;
  transform: translateZ(0);
  box-shadow: 0 0 1px rgba(0, 0, 0, 0);
  backface-visibility: hidden;
  position: relative;
  background-color: #fafafa;
  transition-property: color;
  transition-duration: 0.3s;
}
/*:before这个是颜色扩散动效的重点*/
.hvr-rectangle-out:before {
  content: &amp;quot;&amp;quot;;
  position: absolute;
  z-index: -1;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  transform: scale(0.5);
  transition-property: transform;
  transition-duration: 0.2s;
  transition-timing-function: ease-out;
}
.hvr-rectangle-out:hover,
.hvr-rectangle-out:focus,
.hvr-rectangle-out:active {
  color: white; /*颜色扩散时候，字体改变颜色*/
}
.hvr-rectangle-out:hover:before,
.hvr-rectangle-out:focus:before,
.hvr-rectangle-out:active:before {
  background: #2098d1;
  transform: scale(1); /*hover触发:before层的扩散*/
}

/*弹性收缩动效部分*/
/*使用keyframes定义弹性动画
  1是原来的比例扩散到1.05倍的比例，再缩回1倍原来的比例*/
@keyframes hvr-pop {
  25% {
    -webkit-transform: scale(1);
    transform: scale(1);
  }
  50% {
    -webkit-transform: scale(1);
    transform: scale(1);
  }
  75% {
    -webkit-transform: scale(1.05);
    transform: scale(1.05);
  }
  100% {
    -webkit-transform: scale(1);
    transform: scale(1);
  }
}
.hvr-pop {
  display: inline-block;
  vertical-align: middle;
  transform: translateZ(0);
  box-shadow: 0 0 1px rgba(0, 0, 0, 0);
  backface-visibility: hidden;
  width: 50px;
  height: 50px;
  text-align: center;
  line-height: 50px;
}
.hvr-pop:hover, .hvr-pop:focus, .hvr-pop:active {
  animation-name: hvr-pop;
  animation-duration: 0.3s;
  animation-timing-function: linear;
  animation-iteration-count: 1;
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Centos下搭建DNS服务器 by yunjiang</title>
      <link>http://onecampus.github.io/%E6%90%AD%E5%BB%BADNS%E6%9C%8D%E5%8A%A1%E5%99%A8%20by%20yunjiang/</link>
      <pubDate>Tue, 29 Sep 2015 15:34:00 +0800</pubDate>
      
      <guid>http://onecampus.github.io/%E6%90%AD%E5%BB%BADNS%E6%9C%8D%E5%8A%A1%E5%99%A8%20by%20yunjiang/</guid>
      <description>

&lt;h3 id=&#34;1-yum-y-install-bind-安装bind:2966bf4a81aa2769fb12d1b7246579a7&#34;&gt;1.yum -y install bind 安装bind&lt;/h3&gt;

&lt;h3 id=&#34;2-vim-etc-named-conf-修改named-conf文件的options如下:2966bf4a81aa2769fb12d1b7246579a7&#34;&gt;2.vim /etc/named.conf 修改named.conf文件的options如下:&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;options {
        listen-on port 53 { any; };
        //listen-on-v6 port 53 { ::1; };
        directory       &amp;quot;/var/named&amp;quot;;
        dump-file       &amp;quot;/var/named/data/cache_dump.db&amp;quot;;
        statistics-file &amp;quot;/var/named/data/named_stats.txt&amp;quot;;
        memstatistics-file &amp;quot;/var/named/data/named_mem_stats.txt&amp;quot;;
        allow-query     { any; };
        recursion yes;

        dnssec-enable yes;
        dnssec-validation yes;
        dnssec-lookaside auto;

        /* Path to ISC DLV key */
        bindkeys-file &amp;quot;/etc/named.iscdlv.key&amp;quot;;

        managed-keys-directory &amp;quot;/var/named/dynamic&amp;quot;;
};
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;3-vim-etc-named-rfc1912-zones-在named-rfc1912-zones最下面添加:2966bf4a81aa2769fb12d1b7246579a7&#34;&gt;3.vim /etc/named.rfc1912.zones，在named.rfc1912.zones最下面添加&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;zone &amp;quot;ags.com&amp;quot; IN {
        type master;
        file &amp;quot;named.ags.com&amp;quot;;
        allow-update {none;};
};
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;4-vim-var-named-named-ags-com-添加named-ags-com文件-文件内容如下:2966bf4a81aa2769fb12d1b7246579a7&#34;&gt;4.vim /var/named/named.ags.com 添加named.ags.com文件，文件内容如下：&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;$TTL 1D
@     IN SOA ags.com rname.invalid. (
                         0    ;  serial 
                        1D    ;  refresh
                        1H    ;  retry
                        1W    ;  expire
                        3H )   ;  minimum
      NS   @
      A    127.0.0.1
      AAAA ::1
CYYDMKE   IN A 192.168.1.10  //这里的ip要改为本机ip
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;如此设置之后-访问的域名就会固定为-cyydmke-ags-com:2966bf4a81aa2769fb12d1b7246579a7&#34;&gt;如此设置之后，访问的域名就会固定为 CYYDMKE.ags.com&lt;/h5&gt;

&lt;h3 id=&#34;5-配置路由器dns地址-找到dhcp服务器-修改首选dns服务器:2966bf4a81aa2769fb12d1b7246579a7&#34;&gt;5.配置路由器DNS地址（找到DHCP服务器，修改首选DNS服务器）&lt;/h3&gt;
</description>
    </item>
    
    <item>
      <title>ngrok 简单服务器搭建 by june</title>
      <link>http://onecampus.github.io/ngrok%20%E7%AE%80%E5%8D%95%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BA%20by%20june/</link>
      <pubDate>Sun, 20 Sep 2015 10:14:34 +0800</pubDate>
      
      <guid>http://onecampus.github.io/ngrok%20%E7%AE%80%E5%8D%95%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BA%20by%20june/</guid>
      <description>

&lt;h2 id=&#34;ngrok介绍:4f3ca5663e6fe63f7d854ee2feb8a06c&#34;&gt;ngrok介绍&lt;/h2&gt;

&lt;p&gt;ngrok 是一个反向代理，通过在公共的端点和本地运行的 Web 服务器之间建立一个安全的通道。ngrok 可捕获和分析所有通道上的流量，便于后期分析和重放(来自百度百科)。通过ngrok,我们可以在外网轻松访问本机的资源(其中一个非常重要的功能)。在微信公众号等的开发中，ngrok将大大节省开发者的调试，测试时间和成本,可谓神器!&lt;/p&gt;

&lt;h2 id=&#34;mac-搭建ngrok服务器:4f3ca5663e6fe63f7d854ee2feb8a06c&#34;&gt;Mac 搭建ngrok服务器&lt;/h2&gt;

&lt;p&gt;1.下载ngrok,地址：&lt;a href=&#34;https://ngrok.com/download。&#34;&gt;https://ngrok.com/download。&lt;/a&gt; 请注意:下载官方1.x客户端，官方目前并不准备开放2.0客户端的第三方服务器支持。安装了brew的用户可直接 brew install ngrok,中途会提示安装go,选择是就行了，简单粗暴.&lt;/p&gt;

&lt;p&gt;2.去官网注册一个账号并获取密钥，地址：&lt;a href=&#34;https://ngrok.com/&#34;&gt;https://ngrok.com/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;3.运行$ ngrok -authtoken YOUR_TOKEN_HERE 80（这是一个默认的配置，默认访问：&lt;a href=&#34;http://127.0.0.1）ngrok&#34;&gt;http://127.0.0.1）ngrok&lt;/a&gt; -authtoken只需要运行一次，以后都不需要再次运行, 端口可以随便改&lt;/p&gt;

&lt;p&gt;4.配置一级域名：$ ngrok -subdomain = june(任何你喜欢的英文) 80&lt;/p&gt;

&lt;p&gt;5.由于ngrok默认是部署在国外的服务器，很多时候都不能访问或者访问很慢，因此，我们可以使用部署在国内的服务器， 详情请访问:&lt;a href=&#34;http://www.tunnel.mobi/&#34;&gt;http://www.tunnel.mobi/&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;更多信息:4f3ca5663e6fe63f7d854ee2feb8a06c&#34;&gt;更多信息&lt;/h2&gt;

&lt;p&gt;访问 &lt;a href=&#34;http://www.tunnel.mobi/&#34;&gt;http://www.tunnel.mobi/&lt;/a&gt;, &lt;a href=&#34;https://ngrok.com/docs&#34;&gt;https://ngrok.com/docs&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;补充-由于-官方已经停止发布ngrok1-x版本-官网只能获取2-x-而并不能获取1-x的token-解决方法-待续:4f3ca5663e6fe63f7d854ee2feb8a06c&#34;&gt;补充： 由于 官方已经停止发布ngrok1.x版本，官网只能获取2.x,而并不能获取1.x的token&amp;hellip;=.=, 解决方法，待续。。。&lt;/h3&gt;
</description>
    </item>
    
    <item>
      <title>Android右滑关闭当前页面实现 by fostion</title>
      <link>http://onecampus.github.io/Android%E5%8F%B3%E6%BB%91%E5%85%B3%E9%97%AD%E5%BD%93%E5%89%8D%E9%A1%B5%E9%9D%A2%E5%AE%9E%E7%8E%B0%20by%20fostion/</link>
      <pubDate>Fri, 11 Sep 2015 16:00:16 +0800</pubDate>
      
      <guid>http://onecampus.github.io/Android%E5%8F%B3%E6%BB%91%E5%85%B3%E9%97%AD%E5%BD%93%E5%89%8D%E9%A1%B5%E9%9D%A2%E5%AE%9E%E7%8E%B0%20by%20fostion/</guid>
      <description>

&lt;h2 id=&#34;viewdraghelper介绍:12e2a8ca259c2875a3b1a12e6233ec76&#34;&gt;ViewDragHelper介绍&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;ViewDragHelper 是官方提供我们简单处理ViewGroup内部拖动某个子view处理，同时还可以多手指处理、加速度检测
等,用于代替onInterceptTouchEvent和onTouchEvent处理一些复杂的问题.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;viewdraghelper使用:12e2a8ca259c2875a3b1a12e6233ec76&#34;&gt;ViewDragHelper使用&lt;/h2&gt;

&lt;h4 id=&#34;拦截触碰事件:12e2a8ca259c2875a3b1a12e6233ec76&#34;&gt;拦截触碰事件：&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;    @Override
    public boolean onInterceptTouchEvent(MotionEvent ev) {
        return mViewDragHelper != null ? mViewDragHelper.shouldInterceptTouchEvent(ev) 
                                                          : super.onInterceptTouchEvent(ev);
    }

    @Override
    public boolean onTouchEvent(MotionEvent event) {
        if (mViewDragHelper != null) {
            mViewDragHelper.processTouchEvent(event);
        }
        return true;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;这里我们拦截所有事件，其实可以根据实际需要拦截相应的事件。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;事件处理:12e2a8ca259c2875a3b1a12e6233ec76&#34;&gt;事件处理&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;    @Override
      public boolean tryCaptureView(View child, int pointerId) {
       return child == mContentView;//只有第一个子view才可以移动
     }
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;截取事件后我们可根据需要判断是否处理，返回true就是处理view&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;
    @Override
    protected void onLayout(boolean changed, int l, int t, int r, int b) {
        super.onLayout(changed, l, t, r, b);
        //获取需要拖动的宽度
        mContentWidth = mContentView.getWidth();
    }

    @Override
    protected void onFinishInflate() {
        super.onFinishInflate();
        if (getChildCount() != 1) {
            throw new IllegalStateException(&amp;quot;SwipeBackLayout only have one child view&amp;quot;);
        }
        mContentView = getChildAt(0);
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;获得滑动的view,同时确保必须要只包含一个子view，去报拖动整个view&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;    /**
     * 记录向左移动的值
     */
    @Override
    public void onViewPositionChanged(View changedView, int left, int top, int dx, int dy) {
    mMoveLeft = left;
    if (isClose &amp;amp;&amp;amp; (left == mContentWidth)) {
    if (mDragCallBack != null) {
        mDragCallBack.onDrag();
            }
          }
        }
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;如果当前状态是关闭状态且左边的值等于滑动的View的宽度，也就是说当前的界面已经滑出屏幕后，通知activity可以finish了&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;    /**
     * 手指释放view触发效果：
     * 若是距离不够就弹回去
     */
    @Override
      public void onViewReleased(View releasedChild, float xvel, float yvel) {
      //借助computeScroll方法 移动距离大于四分之一将会关闭否则弹回
      if (mMoveLeft &amp;gt;= (mContentWidth / 4)) {
          //划出屏幕
          isClose = true;
          mViewDragHelper.settleCapturedViewAt(mContentWidth, releasedChild.getTop());
       } else {
           //返回原来位置
            isClose = false;
            mViewDragHelper.settleCapturedViewAt(0, releasedChild.getTop());
            }
            invalidate();
       }

      @Override
      public int clampViewPositionHorizontal(View child, int left, int dx) {
         return Math.min(mContentWidth, Math.max(left, 0));
      }

      @Override
         public int getViewHorizontalDragRange(View child) {
         return mContentWidth;
      }
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;设置滑动的区域和手指离开屏幕后的处理&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;    @Override
    public void computeScroll() {
        super.computeScroll();
        if (mViewDragHelper != null &amp;amp;&amp;amp; mViewDragHelper.continueSettling(true)) {
            invalidate();
        }
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;计算根据抬手后的位置滑动到需要滑动的位置，并刷新&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;    backLayout.setDragCallBack(new SwipeBackLayout.DragCallBack() {
            @Override
            public void onDrag() {
                finish();
            }
     });
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;处理回调，结束当前页面&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;最后Activity主题添加
&lt;code&gt;
&amp;lt;item name=&amp;quot;android:windowIsTranslucent&amp;quot;&amp;gt;true&amp;lt;/item&amp;gt;
&amp;lt;item name=&amp;quot;android:windowBackground&amp;quot;&amp;gt;@android:color/transparent&amp;lt;/item&amp;gt;
&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;显示就没有白色背景了&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;效果图&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&#34;../fostion_result1.jpg&#34; alt=&#34;xiaoguotupian&#34; /&gt;
&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>hugo 基础教程 by nekocode</title>
      <link>http://onecampus.github.io/hugo%20%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%20by%20nekocode/</link>
      <pubDate>Thu, 10 Sep 2015 10:14:34 +0800</pubDate>
      
      <guid>http://onecampus.github.io/hugo%20%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%20by%20nekocode/</guid>
      <description>

&lt;h2 id=&#34;hugo-download:3e7ca7ba07a85115bf01c033d09ed7f6&#34;&gt;Hugo Download&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/spf13/hugo/releases&#34;&gt;https://github.com/spf13/hugo/releases&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;hugo-初尝:3e7ca7ba07a85115bf01c033d09ed7f6&#34;&gt;Hugo 初尝&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;hugo new site hugo_blog
cd hugo_blog

hugo new first.md
hugo undraft content/first.md

mkdir themes
cd themes
git clone https://github.com/spf13/hyde.git
cd hyde
rm -rf .git

cd ..
cd ..
hugo server -t hyde --watch
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;website-configuration:3e7ca7ba07a85115bf01c033d09ed7f6&#34;&gt;Website Configuration&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;&lt;code&gt;toml&lt;/code&gt; or &lt;code&gt;yaml&lt;/code&gt; or &lt;code&gt;json&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;baseurl = &amp;quot;http://onecampus.github.io/&amp;quot;
languageCode = &amp;quot;zh-CN&amp;quot;
title = &amp;quot;Onecampus T.D.&amp;quot;
theme = &amp;quot;hyde&amp;quot;

[params]
	description = &amp;quot;I am the bone of my sword.&amp;quot;
	#disqusShortname = &amp;quot;spf13&amp;quot;

[[menu.main]]
	Name = &amp;quot;organization&amp;quot;
	Url = &amp;quot;https://github.com/onecampus&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;more about &lt;strong&gt;&lt;code&gt;toml&lt;/code&gt;&lt;/strong&gt;：&lt;a href=&#34;http://segmentfault.com/a/1190000000477752&#34;&gt;http://segmentfault.com/a/1190000000477752&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;more about &lt;strong&gt;&lt;code&gt;configuration&lt;/code&gt;&lt;/strong&gt;：&lt;a href=&#34;http://gohugo.io/overview/configuration/&#34;&gt;http://gohugo.io/overview/configuration/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;用-hugo-编写团队博客:3e7ca7ba07a85115bf01c033d09ed7f6&#34;&gt;用 Hugo 编写团队博客&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;fork&lt;/strong&gt; &lt;a href=&#34;https://github.com/onecampus/onecampus_blog&#34;&gt;https://github.com/onecampus/onecampus_blog&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;write articles&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;pull requests&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;other:3e7ca7ba07a85115bf01c033d09ed7f6&#34;&gt;Other&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;themes&lt;/strong&gt;：&lt;a href=&#34;https://github.com/spf13/hugoThemes&#34;&gt;https://github.com/spf13/hugoThemes&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;syntax higlighting&lt;/strong&gt;：&lt;a href=&#34;http://gohugo.io/extras/highlighting&#34;&gt;http://gohugo.io/extras/highlighting&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;默认的 Server-Side 着色有问题，建议改为 Client-Side Syntax Highlighting，使用 &lt;strong&gt;&lt;a href=&#34;https://highlightjs.org/&#34;&gt;highlight.js&lt;/a&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
  </channel>
</rss>